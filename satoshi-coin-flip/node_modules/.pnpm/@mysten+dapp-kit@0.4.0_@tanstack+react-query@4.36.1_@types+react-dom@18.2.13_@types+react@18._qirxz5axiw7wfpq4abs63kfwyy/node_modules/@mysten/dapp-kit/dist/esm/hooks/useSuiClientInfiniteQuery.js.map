{
  "version": 3,
  "sources": ["../../../src/hooks/useSuiClientInfiniteQuery.ts", "../../../src/hooks/useSuiClient.ts", "../../../src/components/SuiClientProvider.tsx"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui.js/client';\nimport type { UseInfiniteQueryOptions } from '@tanstack/react-query';\nimport { useInfiniteQuery } from '@tanstack/react-query';\n\nimport { useSuiClientContext } from './useSuiClient.js';\n\ninterface PaginatedResult {\n\tdata?: unknown;\n\tnextCursor?: unknown;\n\thasNextPage: boolean;\n}\nexport type SuiRpcPaginatedMethodName = {\n\t[K in keyof SuiClient]: SuiClient[K] extends (input: any) => Promise<PaginatedResult> ? K : never;\n}[keyof SuiClient];\n\nexport type SuiRpcPaginatedMethods = {\n\t[K in SuiRpcPaginatedMethodName]: SuiClient[K] extends (input: infer P) => Promise<{\n\t\tdata?: infer R;\n\t\tnextCursor?: infer Cursor | null;\n\t\thasNextPage: boolean;\n\t}>\n\t\t? {\n\t\t\t\tname: K;\n\t\t\t\tresult: R;\n\t\t\t\tparams: P;\n\t\t\t\tcursor: Cursor;\n\t\t  }\n\t\t: never;\n};\n\nexport type UseSuiClientInfiniteQueryOptions<T extends keyof SuiRpcPaginatedMethods> = Omit<\n\tUseInfiniteQueryOptions<\n\t\tSuiRpcPaginatedMethods[T]['result'],\n\t\tError,\n\t\tSuiRpcPaginatedMethods[T]['result'],\n\t\tSuiRpcPaginatedMethods[T]['result'],\n\t\tunknown[]\n\t>,\n\t'queryFn'\n>;\n\nexport function useSuiClientInfiniteQuery<T extends keyof SuiRpcPaginatedMethods>(\n\tmethod: T,\n\tparams: SuiRpcPaginatedMethods[T]['params'],\n\t{ queryKey = [], enabled = !!params, ...options }: UseSuiClientInfiniteQueryOptions<T> = {},\n) {\n\tconst suiContext = useSuiClientContext();\n\n\treturn useInfiniteQuery({\n\t\t...options,\n\t\tqueryKey: [suiContext.network, method, params, ...queryKey],\n\t\tenabled,\n\t\tqueryFn: async () => {\n\t\t\treturn await suiContext.client[method](params as never);\n\t\t},\n\t\tgetNextPageParam: (lastPage) => {\n\t\t\treturn (lastPage as PaginatedResult).nextCursor ?? null;\n\t\t},\n\t});\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SuiClient } from '@mysten/sui.js/client';\nimport { useContext } from 'react';\n\nimport { SuiClientContext } from '../components/SuiClientProvider.js';\n\nexport function useSuiClientContext() {\n\tconst suiClient = useContext(SuiClientContext);\n\n\tif (!suiClient) {\n\t\tthrow new Error(\n\t\t\t'Could not find SuiClientContext. Ensure that you have set up the SuiClientProvider',\n\t\t);\n\t}\n\n\treturn suiClient;\n}\n\nexport function useSuiClient(): SuiClient {\n\treturn useSuiClientContext().client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { getFullnodeUrl, isSuiClient, SuiClient } from '@mysten/sui.js/client';\nimport type { SuiClientOptions } from '@mysten/sui.js/client';\nimport { createContext, useMemo, useState } from 'react';\n\ntype NetworkConfig = SuiClient | SuiClientOptions;\ntype NetworkConfigs<T extends NetworkConfig = NetworkConfig> = Record<string, T>;\n\nexport interface SuiClientProviderContext {\n\tclient: SuiClient;\n\tnetworks: NetworkConfigs;\n\tnetwork: string;\n\tselectNetwork: (network: string) => void;\n}\n\nexport const SuiClientContext = createContext<SuiClientProviderContext | null>(null);\n\nexport type SuiClientProviderProps<T extends NetworkConfigs> = {\n\tcreateClient?: (name: keyof T, config: T[keyof T]) => SuiClient;\n\tchildren: React.ReactNode;\n\tnetworks?: T;\n\tonNetworkChange?: (network: keyof T & string) => void;\n} & (\n\t| {\n\t\t\tdefaultNetwork?: keyof T & string;\n\t\t\tnetwork?: never;\n\t  }\n\t| {\n\t\t\tdefaultNetwork?: never;\n\t\t\tnetwork?: keyof T & string;\n\t  }\n);\n\nconst DEFAULT_NETWORKS = {\n\tlocalnet: { url: getFullnodeUrl('localnet') },\n};\n\nconst DEFAULT_CREATE_CLIENT = function createClient(\n\t_name: string,\n\tconfig: NetworkConfig | SuiClient,\n) {\n\tif (isSuiClient(config)) {\n\t\treturn config;\n\t}\n\n\treturn new SuiClient(config);\n};\n\nexport function SuiClientProvider<T extends NetworkConfigs>(props: SuiClientProviderProps<T>) {\n\tconst { onNetworkChange, network, children } = props;\n\tconst networks = (props.networks ?? DEFAULT_NETWORKS) as T;\n\tconst createClient =\n\t\t(props.createClient as typeof DEFAULT_CREATE_CLIENT) ?? DEFAULT_CREATE_CLIENT;\n\n\tconst [selectedNetwork, setSelectedNetwork] = useState<keyof T & string>(\n\t\tprops.network ?? props.defaultNetwork ?? (Object.keys(networks)[0] as keyof T & string),\n\t);\n\n\tconst currentNetwork = props.network ?? selectedNetwork;\n\n\tconst client = useMemo(() => {\n\t\treturn createClient(currentNetwork, networks[currentNetwork]);\n\t}, [createClient, currentNetwork, networks]);\n\n\tconst ctx = useMemo((): SuiClientProviderContext => {\n\t\treturn {\n\t\t\tclient,\n\t\t\tnetworks,\n\t\t\tnetwork: currentNetwork,\n\t\t\tselectNetwork: (newNetwork) => {\n\t\t\t\tif (currentNetwork === newNetwork) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!network && newNetwork !== selectedNetwork) {\n\t\t\t\t\tsetSelectedNetwork(newNetwork);\n\t\t\t\t}\n\n\t\t\t\tonNetworkChange?.(newNetwork);\n\t\t\t},\n\t\t};\n\t}, [client, networks, selectedNetwork, currentNetwork, network, onNetworkChange]);\n\n\treturn <SuiClientContext.Provider value={ctx}>{children}</SuiClientContext.Provider>;\n}\n"],
  "mappings": ";AAKA,SAAS,wBAAwB;;;ACDjC,SAAS,kBAAkB;;;ACD3B,SAAS,gBAAgB,aAAa,iBAAiB;AAEvD,SAAS,eAAe,SAAS,gBAAgB;AAgFzC;AApED,IAAM,mBAAmB,cAA+C,IAAI;AAkBnF,IAAM,mBAAmB;AAAA,EACxB,UAAU,EAAE,KAAK,eAAe,UAAU,EAAE;AAC7C;;;AD7BO,SAAS,sBAAsB;AACrC,QAAM,YAAY,WAAW,gBAAgB;AAE7C,MAAI,CAAC,WAAW;AACf,UAAM,IAAI;AAAA,MACT;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AACR;;;AD0BO,SAAS,0BACf,QACA,QACA,EAAE,WAAW,CAAC,GAAG,UAAU,CAAC,CAAC,QAAQ,GAAG,QAAQ,IAAyC,CAAC,GACzF;AACD,QAAM,aAAa,oBAAoB;AAEvC,SAAO,iBAAiB;AAAA,IACvB,GAAG;AAAA,IACH,UAAU,CAAC,WAAW,SAAS,QAAQ,QAAQ,GAAG,QAAQ;AAAA,IAC1D;AAAA,IACA,SAAS,YAAY;AACpB,aAAO,MAAM,WAAW,OAAO,MAAM,EAAE,MAAe;AAAA,IACvD;AAAA,IACA,kBAAkB,CAAC,aAAa;AAC/B,aAAQ,SAA6B,cAAc;AAAA,IACpD;AAAA,EACD,CAAC;AACF;",
  "names": []
}

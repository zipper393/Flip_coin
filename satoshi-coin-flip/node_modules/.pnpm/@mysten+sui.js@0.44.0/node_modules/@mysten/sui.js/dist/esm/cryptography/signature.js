import { fromB64, toB64 } from "@mysten/bcs";
import { bcs } from "../bcs/index.js";
import { computeZkLoginAddressFromSeed } from "../zklogin/address.js";
import { extractClaimValue } from "../zklogin/jwt-utils.js";
import { parseZkLoginSignature } from "../zklogin/signature.js";
import {
  SIGNATURE_FLAG_TO_SCHEME,
  SIGNATURE_SCHEME_TO_FLAG,
  SIGNATURE_SCHEME_TO_SIZE
} from "./signature-scheme.js";
function toSerializedSignature({
  signature,
  signatureScheme,
  publicKey
}) {
  if (!publicKey) {
    throw new Error("`publicKey` is required");
  }
  const pubKeyBytes = publicKey.toRawBytes();
  const serializedSignature = new Uint8Array(1 + signature.length + pubKeyBytes.length);
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKeyBytes, 1 + signature.length);
  return toB64(serializedSignature);
}
function parseSerializedSignature(serializedSignature) {
  const bytes = fromB64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];
  if (signatureScheme === "MultiSig") {
    const multisig = bcs.MultiSig.parse(bytes.slice(1));
    return {
      serializedSignature,
      signatureScheme,
      multisig,
      bytes
    };
  }
  if (signatureScheme === "ZkLogin") {
    const signatureBytes = bytes.slice(1);
    const { inputs, maxEpoch, userSignature } = parseZkLoginSignature(signatureBytes);
    const { issBase64Details, addressSeed } = inputs;
    const iss = extractClaimValue(issBase64Details, "iss");
    const address = computeZkLoginAddressFromSeed(BigInt(addressSeed), iss);
    return {
      serializedSignature,
      signatureScheme,
      zkLogin: {
        inputs,
        maxEpoch,
        userSignature,
        iss,
        address
      },
      bytes
    };
  }
  if (!(signatureScheme in SIGNATURE_SCHEME_TO_SIZE)) {
    throw new Error("Unsupported signature scheme");
  }
  const size = SIGNATURE_SCHEME_TO_SIZE[signatureScheme];
  const signature = bytes.slice(1, bytes.length - size);
  const publicKey = bytes.slice(1 + signature.length);
  return {
    serializedSignature,
    signatureScheme,
    signature,
    publicKey,
    bytes
  };
}
export {
  parseSerializedSignature,
  toSerializedSignature
};
//# sourceMappingURL=signature.js.map

import {
  BCS,
  SUI_ADDRESS_LENGTH,
  bcs,
  fromB58,
  fromHEX,
  getSuiMoveConfig,
  normalizeSuiAddress,
  splitGenericParameters,
  toB58,
  toHEX
} from "./chunk-RZHKCPGW.js";

// node_modules/.pnpm/@mysten+sui.js@0.44.0/node_modules/@mysten/sui.js/dist/esm/bcs/type-tag-serializer.js
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class _TypeTagSerializer {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: _TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : _TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)
        }
      };
    }
    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    return splitGenericParameters(str).map(
      (tok) => _TypeTagSerializer.parseFromStr(tok, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${_TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(_TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};

// node_modules/.pnpm/@mysten+sui.js@0.44.0/node_modules/@mysten/sui.js/dist/esm/bcs/index.js
function isPureArg(arg) {
  return arg.Pure !== void 0;
}
var bcsRegistry = new BCS({
  ...getSuiMoveConfig(),
  types: {
    enums: {
      "Option<T>": {
        None: null,
        Some: "T"
      }
    }
  }
});
function unsafe_u64(options) {
  return bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type) {
  return bcs.enum("Option", {
    None: null,
    Some: type
  });
}
function enumKind(type) {
  return type.transform({
    input: (val) => ({
      [val.kind]: val
    }),
    output: (val) => {
      const key = Object.keys(val)[0];
      return { kind: key, ...val[key] };
    }
  });
}
var Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({
  input: (val) => typeof val === "string" ? fromHEX(normalizeSuiAddress(val)) : val,
  output: (val) => toHEX(val)
});
var ObjectDigest = bcs.vector(bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value) => fromB58(value),
  output: (value) => toB58(new Uint8Array(value))
});
var SuiObjectRef = bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: bcs.u64(),
  digest: ObjectDigest
});
var SharedObjectRef = bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: bcs.u64(),
  mutable: bcs.bool()
});
var ObjectArg = bcs.enum("ObjectArg", {
  ImmOrOwned: SuiObjectRef,
  Shared: SharedObjectRef
});
var CallArg = bcs.enum("CallArg", {
  Pure: bcs.vector(bcs.u8()),
  Object: ObjectArg,
  ObjVec: bcs.vector(ObjectArg)
});
var TypeTag = bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: bcs.lazy(() => TypeTag),
  struct: bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
var Argument = enumKind(
  bcs.enum("Argument", {
    GasCoin: null,
    Input: bcs.struct("Input", { index: bcs.u16() }),
    Result: bcs.struct("Result", { index: bcs.u16() }),
    NestedResult: bcs.struct("NestedResult", { index: bcs.u16(), resultIndex: bcs.u16() })
  })
);
var ProgrammableMoveCall = bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: bcs.string(),
  function: bcs.string(),
  type_arguments: bcs.vector(TypeTag),
  arguments: bcs.vector(Argument)
}).transform({
  input: (data) => {
    const [pkg, module, fun] = data.target.split("::");
    const type_arguments = data.typeArguments.map(
      (tag) => TypeTagSerializer.parseFromStr(tag, true)
    );
    return {
      package: normalizeSuiAddress(pkg),
      module,
      function: fun,
      type_arguments,
      arguments: data.arguments
    };
  },
  output: (data) => {
    return {
      target: [data.package, data.module, data.function].join(
        "::"
      ),
      arguments: data.arguments,
      typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)
    };
  }
});
var Transaction = enumKind(
  bcs.enum("Transaction", {
    /**
     * A Move Call - any public Move function can be called via
     * this transaction. The results can be used that instant to pass
     * into the next transaction.
     */
    MoveCall: ProgrammableMoveCall,
    /**
     * Transfer vector of objects to a receiver.
     */
    TransferObjects: bcs.struct("TransferObjects", {
      objects: bcs.vector(Argument),
      address: Argument
    }),
    /**
     * Split `amount` from a `coin`.
     */
    SplitCoins: bcs.struct("SplitCoins", { coin: Argument, amounts: bcs.vector(Argument) }),
    /**
     * Merge Vector of Coins (`sources`) into a `destination`.
     */
    MergeCoins: bcs.struct("MergeCoins", { destination: Argument, sources: bcs.vector(Argument) }),
    /**
     * Publish a Move module.
     */
    Publish: bcs.struct("Publish", {
      modules: bcs.vector(bcs.vector(bcs.u8())),
      dependencies: bcs.vector(Address)
    }),
    /**
     * Build a vector of objects using the input arguments.
     * It is impossible to construct a `vector<T: key>` otherwise,
     * so this call serves a utility function.
     */
    MakeMoveVec: bcs.struct("MakeMoveVec", {
      type: optionEnum(TypeTag),
      objects: bcs.vector(Argument)
    }),
    /**  */
    Upgrade: bcs.struct("Upgrade", {
      modules: bcs.vector(bcs.vector(bcs.u8())),
      dependencies: bcs.vector(Address),
      packageId: Address,
      ticket: Argument
    })
  })
);
var ProgrammableTransaction = bcs.struct("ProgrammableTransaction", {
  inputs: bcs.vector(CallArg),
  transactions: bcs.vector(Transaction)
});
var TransactionKind = bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
var TransactionExpiration = bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
var StructTag = bcs.struct("StructTag", {
  address: Address,
  module: bcs.string(),
  name: bcs.string(),
  typeParams: bcs.vector(TypeTag)
});
var GasData = bcs.struct("GasData", {
  payment: bcs.vector(SuiObjectRef),
  owner: Address,
  price: bcs.u64(),
  budget: bcs.u64()
});
var TransactionDataV1 = bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
var TransactionData = bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
var SenderSignedData = bcs.struct("SenderSignedData", {
  data: TransactionData,
  txSignatures: bcs.vector(bcs.vector(bcs.u8()))
});
var CompressedSignature = bcs.enum("CompressedSignature", {
  ED25519: bcs.fixedArray(64, bcs.u8()),
  Secp256k1: bcs.fixedArray(64, bcs.u8()),
  Secp256r1: bcs.fixedArray(64, bcs.u8())
});
var PublicKey = bcs.enum("PublicKey", {
  ED25519: bcs.fixedArray(32, bcs.u8()),
  Secp256k1: bcs.fixedArray(33, bcs.u8()),
  Secp256r1: bcs.fixedArray(33, bcs.u8())
});
var MultiSigPkMap = bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: bcs.u8()
});
var MultiSigPublicKey = bcs.struct("MultiSigPublicKey", {
  pk_map: bcs.vector(MultiSigPkMap),
  threshold: bcs.u16()
});
var MultiSig = bcs.struct("MultiSig", {
  sigs: bcs.vector(CompressedSignature),
  bitmap: bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
var suiBcs = {
  ...bcs,
  U8: bcs.u8(),
  U16: bcs.u16(),
  U32: bcs.u32(),
  U64: bcs.u64(),
  U128: bcs.u128(),
  U256: bcs.u256(),
  ULEB128: bcs.uleb128(),
  Bool: bcs.bool(),
  String: bcs.string(),
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag,
  // preserve backwards compatibility with old bcs export
  ser: bcsRegistry.ser.bind(bcsRegistry),
  de: bcsRegistry.de.bind(bcsRegistry),
  getTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),
  hasType: bcsRegistry.hasType.bind(bcsRegistry),
  parseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),
  registerAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),
  registerAlias: bcsRegistry.registerAlias.bind(bcsRegistry),
  registerBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),
  registerEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),
  registerStructType: bcsRegistry.registerStructType.bind(bcsRegistry),
  registerType: bcsRegistry.registerType.bind(bcsRegistry),
  types: bcsRegistry.types
};
bcsRegistry.registerBcsType("utf8string", () => bcs.string({ name: "utf8string" }));
bcsRegistry.registerBcsType("unsafe_u64", () => unsafe_u64());
bcsRegistry.registerBcsType("enumKind", (T) => enumKind(T));
[
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag
].forEach((type) => {
  bcsRegistry.registerBcsType(type.name, () => type);
});

export {
  TypeTagSerializer,
  isPureArg,
  bcsRegistry,
  suiBcs
};
//# sourceMappingURL=chunk-QNXVCWGQ.js.map
